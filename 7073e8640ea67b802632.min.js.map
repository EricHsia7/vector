{"version":3,"file":"7073e8640ea67b802632.min.js","mappings":"4HAwBO,SAASA,EAAYC,EAAMC,EAAMC,EAAQC,EAAQC,EAAMC,EAAYC,EAAgBC,EAA0BC,EAAkCC,EAA8BC,EAAgCC,EAAsBC,EAAkBC,GAC1P,MAAO,CACLb,EAAGA,GAAK,EACRC,EAAGA,GAAK,EACRC,GAAIA,GAAM,EACVC,GAAIA,GAAM,EACVC,EAAGA,GAAK,EACRC,KAAMA,GAAQ,OACdC,OAAQA,GAAU,OAClBC,YAAaA,GAAe,EAC5BC,gBAAiBA,GAAmB,GACpCC,cAAeA,GAAiB,OAChCC,eAAgBA,GAAkB,QAClCC,UAAWA,GAAa,GACxBC,QAASA,GAAW,EACpBC,WAAYA,GAAc,UAC1BC,IAAIC,EAAAA,EAAAA,KACJC,KAAM,SAEV,C,8CClBO,SAASC,EAAajB,EAAMC,EAAMC,EAAQC,EAAQe,EAAQC,EAAQd,EAAYC,EAAgBC,EAA0BC,EAAkCC,EAA8BC,EAAgCC,EAAsBC,EAAkBC,GACrQ,MAAO,CACLb,EAAGA,GAAK,EACRC,EAAGA,GAAK,EACRC,GAAIA,GAAM,EACVC,GAAIA,GAAM,EACVe,GAAIA,GAAM,EACVC,GAAIA,GAAM,EACVd,KAAMA,GAAQ,OACdC,OAAQA,GAAU,OAClBC,YAAaA,GAAe,EAC5BC,gBAAiBA,GAAmB,GACpCC,cAAeA,GAAiB,OAChCC,eAAgBA,GAAkB,QAClCC,UAAWA,GAAa,GACxBC,QAASA,GAAW,EACpBC,WAAYA,GAAc,UAC1BC,IAAIC,EAAAA,EAAAA,KACJC,KAAM,UAEV,C,6CCvBO,SAASI,EAAUC,EAAOC,EAAOC,EAAOC,EAAOlB,EAAgBC,EAA0BC,EAAkCC,EAA8BC,EAAgCC,EAAsBC,EAAkBC,GACtO,MAAO,CACLQ,GAAIA,GAAM,EACVC,GAAIA,GAAM,EACVC,GAAIA,GAAM,EACVC,GAAIA,GAAM,EACVlB,OAAQA,GAAU,OAClBC,YAAaA,GAAe,EAC5BC,gBAAiBA,GAAmB,GACpCC,cAAeA,GAAiB,OAChCC,eAAgBA,GAAkB,QAClCC,UAAWA,GAAa,GACxBC,QAASA,GAAW,EACpBC,WAAYA,GAAc,UAC1BC,IAAIC,EAAAA,EAAAA,KACJC,KAAM,OAEV,C,qqDCTO,SAASS,EAAUC,EAAMC,EAAwBtB,EAAYC,EAAgBC,EAA0BC,EAAkCC,EAA8BC,EAAgCC,EAAsBC,EAAkBC,GACpP,MAAO,CACLa,EAAGA,GAAK,GACRC,WAAYA,GAAc,GAC1BtB,KAAMA,GAAQ,OACdC,OAAQA,GAAU,OAClBC,YAAaA,GAAe,EAC5BC,gBAAiBA,GAAmB,GACpCC,cAAeA,GAAiB,OAChCC,eAAgBA,GAAkB,QAClCC,UAAWA,GAAa,GACxBC,QAASA,GAAW,EACpBC,WAAYA,GAAc,UAC1BC,IAAIC,EAAAA,EAAAA,KACJC,KAAM,OAEV,CAgMO,SAASY,EAAWC,GAAqG,IAAzFC,EAAiBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAAGG,EAAgBH,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAAUI,EAAsBJ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACxGK,EA/LC,SAA4BC,GAA4E,IAA/DP,EAAiBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAAGI,EAAsBJ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAC3F,SAASO,EAAkBC,EAAWC,EAAWV,GAI/C,IAHA,IAAIW,EAAwB,GAEtBC,EADWC,KAAKC,MAAMJ,EAAGxC,EAAIuC,EAAGvC,EAAGwC,EAAGvC,EAAIsC,EAAGtC,GAC3B6B,EACfe,EAAI,EAAGA,GAAKH,EAAMG,IAAK,CAC9B,IAAMC,EAAID,EAAIH,EACR1C,EAAIuC,EAAGvC,GAAKwC,EAAGxC,EAAIuC,EAAGvC,GAAK8C,EAC3B7C,EAAIsC,EAAGtC,GAAKuC,EAAGvC,EAAIsC,EAAGtC,GAAK6C,EACjCL,EAAcM,KAAK,CAAE/C,EAAAA,EAAGC,EAAAA,GAC1B,CACA,OAAOwC,CACT,CAEA,SAASO,EAAuBT,EAAWU,EAAWC,EAAWV,EAAWV,EAAmBK,GAC7F,IAAIM,EAAwB,GACtBU,EAAWR,KAAKC,MAAMJ,EAAGxC,EAAIuC,EAAGvC,EAAGwC,EAAGvC,EAAIsC,EAAGtC,GAC/CyC,EAAOC,KAAKS,MAAMD,EAAWrB,GAC7BK,IACFO,GAAQ,KAEV,IAAK,IAAIG,EAAI,EAAGA,GAAKH,EAAMG,IAAK,CAC9B,IAAMC,EAAID,EAAIH,EACR1C,EAAI2C,KAAKU,IAAI,EAAIP,EAAG,GAAKP,EAAGvC,EAAI,EAAI2C,KAAKU,IAAI,EAAIP,EAAG,GAAKA,EAAIG,EAAGjD,EAAI,GAAK,EAAI8C,GAAKH,KAAKU,IAAIP,EAAG,GAAKI,EAAGlD,EAAI2C,KAAKU,IAAIP,EAAG,GAAKN,EAAGxC,EAC9HC,EAAI0C,KAAKU,IAAI,EAAIP,EAAG,GAAKP,EAAGtC,EAAI,EAAI0C,KAAKU,IAAI,EAAIP,EAAG,GAAKA,EAAIG,EAAGhD,EAAI,GAAK,EAAI6C,GAAKH,KAAKU,IAAIP,EAAG,GAAKI,EAAGjD,EAAI0C,KAAKU,IAAIP,EAAG,GAAKN,EAAGvC,EACpIwC,EAAcM,KAAK,CAAE/C,EAAAA,EAAGC,EAAAA,GAC1B,CACA,OAAOwC,CACT,CAEA,SAASa,EAA2Bf,EAAWgB,EAAUf,EAAWV,EAAmBK,GACrF,IAAIM,EAAwB,GACtBU,EAAWR,KAAKC,MAAMJ,EAAGxC,EAAIuC,EAAGvC,EAAGwC,EAAGvC,EAAIsC,EAAGtC,GAC/CyC,EAAOC,KAAKS,MAAMD,EAAWrB,GAC7BK,IACFO,GAAQ,KAEV,IAAK,IAAIG,EAAI,EAAGA,GAAKH,EAAMG,IAAK,CAC9B,IAAMC,EAAID,EAAIH,EACR1C,EAAI2C,KAAKU,IAAI,EAAIP,EAAG,GAAKP,EAAGvC,EAAI,GAAK,EAAI8C,GAAKA,EAAIN,EAAGxC,EAAI2C,KAAKU,IAAIP,EAAG,GAAKS,EAAEvD,EAC5EC,EAAI0C,KAAKU,IAAI,EAAIP,EAAG,GAAKP,EAAGtC,EAAI,GAAK,EAAI6C,GAAKA,EAAIN,EAAGvC,EAAI0C,KAAKU,IAAIP,EAAG,GAAKS,EAAEtD,EAClFwC,EAAcM,KAAK,CAAE/C,EAAAA,EAAGC,EAAAA,GAC1B,CACA,OAAOwC,CACT,CAEA,SAASe,EAAejB,EAAWrB,EAAYC,EAAYsC,EAAuBC,EAAqBC,EAAkB3D,EAAWC,EAAW6B,EAAmBK,GAChK,IAAMgB,EAAWR,KAAKC,MAAM5C,EAAIuC,EAAGvC,EAAGC,EAAIsC,EAAGtC,GACzCyC,EAAOC,KAAKS,MAAMD,EAAWrB,GAC7BK,IACFO,GAAQ,KAIV,IAGMkB,EAAuBH,EAHYd,KAAKkB,GAAM,IAI9CC,EAASnB,KAAKoB,IAAIH,GAClBI,EAASrB,KAAKsB,IAAIL,GAGlBM,GAAM3B,EAAGvC,EAAIA,GAAK,EAClBmE,GAAM5B,EAAGtC,EAAIA,GAAK,EAGlBmE,EAAMN,EAASI,EAAKF,EAASG,EAC7BE,GAAOL,EAASE,EAAKJ,EAASK,EAG9BG,EAAI3B,KAAAU,IAAGnC,EAAM,GACbqD,EAAI5B,KAAAU,IAAGlC,EAAM,GACbqD,EAAK7B,KAAAU,IAAGe,EAAO,GACfK,EAAK9B,KAAAU,IAAGgB,EAAO,GAEjBK,GAAYJ,EAAOC,EAAOD,EAAOG,EAAQF,EAAOC,IAAUF,EAAOG,EAAQF,EAAOC,GACpFE,EAAW/B,KAAKgC,IAAI,EAAGD,GAoBvB,IAnBA,IAAME,GAAQlB,IAAiBC,EAAY,GAAK,GAAKhB,KAAKkC,KAAKH,GAEzDI,EAAMF,GAAS1D,EAAKmD,EAAOlD,GAC3B4D,EAAMH,IAAUzD,EAAKiD,EAAOlD,GAG5BhB,EAAK4D,EAASgB,EAAMd,EAASe,GAAOxC,EAAGvC,EAAIA,GAAK,EAChDG,EAAK6D,EAASc,EAAMhB,EAASiB,GAAOxC,EAAGtC,EAAIA,GAAK,EAGhD+E,EAASrC,KAAKsC,OAAOZ,EAAMU,GAAO5D,GAAKiD,EAAMU,GAAO5D,GACpDgE,EAAavC,KAAKsC,QAAQZ,EAAMU,GAAO5D,IAAMiD,EAAMU,GAAO5D,GAAM8D,EAGhEG,EAAmC,IAAdxB,GAAmBuB,EAAa,EAAIA,EAAa,EAAIvC,KAAKkB,GAAKqB,EACpFE,EAAgC,IAAdzB,GAAmBuB,EAAa,EAAIA,EAAa,EAAIvC,KAAKkB,GAAKsB,EAGjF1C,EAAgB,GACbI,EAAI,EAAGA,GAAKH,EAAMG,IAAK,CAC9B,IACMwC,EAAQL,EADJnC,EAAIH,EACa0C,EAGrBpF,EAAI8D,GAAU5C,EAAKyB,KAAKoB,IAAIsB,IAAUrB,GAAU7C,EAAKwB,KAAKsB,IAAIoB,IAAUnF,EACxED,EAAI+D,GAAU9C,EAAKyB,KAAKoB,IAAIsB,IAAUvB,GAAU3C,EAAKwB,KAAKsB,IAAIoB,IAAUlF,EAE9EsC,EAAcM,KAAK,CAAE/C,EAAAA,EAAGC,EAAAA,GAC1B,CACA,OAAOwC,CACT,CAEA,IAI8B6C,EAJ1BlD,EAAiB,GACjBmD,EAAsB,CAAEvF,EAAG,EAAGC,EAAG,GACjCuF,EAAqC,KAAKC,EAAAC,EAExBrD,GAAQ,IAA9B,IAAAoD,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAAgC,KAArBC,EAAOR,EAAAS,MAChB,OAAQD,EAAQ9E,MACd,IAAK,IACHuE,EAAe,CAAEvF,EAAG8F,EAAQ9F,EAAGC,EAAG6F,EAAQ7F,GAC1CmC,EAAOW,KAAKwC,GACZC,EAAuB,KACvB,MACF,IAAK,IACH,IAAMQ,EAAU,CAAEhG,EAAG8F,EAAQ9F,EAAGC,EAAG6F,EAAQ7F,GAC3CmC,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAAS5D,EAAkBiD,EAAcS,EAASlE,KACxDyD,EAAeS,EACfR,EAAuB,KACvB,MACF,IAAK,IACH,IAAMW,EAAgB,CAAEnG,EAAG8F,EAAQ9F,EAAGC,EAAGsF,EAAatF,GACtDmC,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAAS5D,EAAkBiD,EAAcY,EAAerE,KAC9DyD,EAAeY,EACfX,EAAuB,KACvB,MACF,IAAK,IACH,IAAMY,EAAc,CAAEpG,EAAGuF,EAAavF,EAAGC,EAAG6F,EAAQ7F,GACpDmC,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAAS5D,EAAkBiD,EAAca,EAAatE,KAC5DyD,EAAea,EACfZ,EAAuB,KACvB,MACF,IAAK,IACH,IAAMa,EAAad,EACbe,EAAgB,CAAEtG,EAAG8F,EAAQzE,GAAIpB,EAAG6F,EAAQxE,IAC5CiF,EAAgB,CAAEvG,EAAG8F,EAAQvE,GAAItB,EAAG6F,EAAQtE,IAC5CgF,EAAW,CAAExG,EAAG8F,EAAQ9F,EAAGC,EAAG6F,EAAQ7F,GAC5CmC,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAASlD,EAAuBqD,EAAYC,EAAeC,EAAeC,EAAU1E,EAAWK,KACrGoD,EAAeiB,EACfhB,EAAuBe,EACvB,MACF,IAAK,IACH,IAAME,EAAclB,EACdmB,EAAiBlB,EAAuB,CAAExF,EAAG,EAAIyG,EAAYzG,EAAIwF,EAAqBxF,EAAGC,EAAG,EAAIwG,EAAYxG,EAAIuF,EAAqBvF,GAAMwG,EAC3IE,EAAiB,CAAE3G,EAAG8F,EAAQvE,GAAItB,EAAG6F,EAAQtE,IAC7CoF,EAAY,CAAE5G,EAAG8F,EAAQ9F,EAAGC,EAAG6F,EAAQ7F,GAC7CmC,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAASlD,EAAuByD,EAAaC,EAAgBC,EAAgBC,EAAW9E,EAAWK,KACzGoD,EAAeqB,EACfpB,EAAuBmB,EACvB,MACF,IAAK,IACH,IAAME,EAAYtB,EACZuB,EAAc,CAAE9G,EAAG8F,EAAQ9F,EAAGC,EAAG6F,EAAQ7F,GACzC8G,EAAU,CAAE/G,EAAG8F,EAAQzE,GAAIpB,EAAG6F,EAAQxE,IAC5Cc,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAAS5C,EAA2BuD,EAAWC,EAAaC,EAASjF,EAAWK,KACtFoD,EAAewB,EACfvB,EAAuBsB,EACvB,MACF,IAAK,IACH,IAAME,EAAkBzB,EAClB0B,EAAoBzB,EAAuB,CAAExF,EAAG,EAAIgH,EAAgBhH,EAAIwF,EAAqBxF,EAAGC,EAAG,EAAI+G,EAAgB/G,EAAIuF,EAAqBvF,GAAM+G,EACtJE,EAAgB,CAAElH,EAAG8F,EAAQ9F,EAAGC,EAAG6F,EAAQ7F,GACjDmC,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAAS5C,EAA2B0D,EAAiBC,EAAmBC,EAAepF,EAAWK,KACxGoD,EAAe2B,EACf1B,EAAuByB,EACvB,MACF,IAAK,IACH7E,EAAOW,KAAIkD,MAAX7D,EAAM8D,EAAS1C,EAAe+B,EAAcO,EAAQ5E,GAAI4E,EAAQ3E,GAAI2E,EAAQrC,cAAeqC,EAAQpC,aAAcoC,EAAQnC,UAAWmC,EAAQ9F,EAAG8F,EAAQ7F,EAAG6B,EAAWK,KACrKoD,EAAe,CAAEvF,EAAG8F,EAAQ9F,EAAGC,EAAG6F,EAAQ7F,GAC1CuF,EAAuB,KACvB,MACF,IAAK,IACCpD,EAAOJ,OAAS,GAClBI,EAAOW,KAAKX,EAAO,IAErBoD,EAAuB,KACvB,MACF,QACE,MAAM,IAAI2B,MAAM,6BAADC,OAA8BtB,EAAQ9E,OAE3D,CAAC,OAAAqG,GAAA5B,EAAA6B,EAAAD,EAAA,SAAA5B,EAAA8B,GAAA,CACD,OAAOnF,CACT,CAGeoF,CAAmB3F,EAAKH,EAAGI,EAAWK,GAQnD,OAPID,GAC4B,WAA1BuF,EAAO5F,EAAKlB,YAA0B+G,MAAMC,QAAQ9F,EAAKlB,YACvDkB,EAAKlB,UAAUqB,OAAS,IAC1BI,GAASwF,EAAAA,EAAAA,IAAgBxF,EAAQP,EAAKlB,YAIrCyB,CACT,CAEO,SAASyF,EAAWhG,GAwDzB,IALA,IACMiG,EAnDN,SAASC,EAAe3F,EAAgB4F,GACtC,SAASC,EAAkBC,EAAcC,EAAcC,GACrD,IAAIlE,EAAKkE,EAAIpI,EAAImI,EAAMnI,EACnBmE,EAAKiE,EAAInI,EAAIkI,EAAMlI,EACnByB,EAAIwC,EAAKA,EAAKC,EAAKA,EACnBrB,IAAMoF,EAAMlI,EAAImI,EAAMnI,GAAKkE,GAAMgE,EAAMjI,EAAIkI,EAAMlI,GAAKkE,GAAMzC,EAEhE,GAAIoB,EAAI,EACNoB,EAAKgE,EAAMlI,EAAImI,EAAMnI,EACrBmE,EAAK+D,EAAMjI,EAAIkI,EAAMlI,OAChB,GAAI6C,EAAI,EACboB,EAAKgE,EAAMlI,EAAIoI,EAAIpI,EACnBmE,EAAK+D,EAAMjI,EAAImI,EAAInI,MACd,CACL,IAAIoI,EAAe,CAAErI,EAAGmI,EAAMnI,EAAI8C,EAAIoB,EAAIjE,EAAGkI,EAAMlI,EAAI6C,EAAIqB,GAC3DD,EAAKgE,EAAMlI,EAAIqI,EAAarI,EAC5BmE,EAAK+D,EAAMjI,EAAIoI,EAAapI,CAC9B,CAEA,OAAO0C,KAAKkC,KAAKX,EAAKA,EAAKC,EAAKA,EAClC,CAEA,GAAI/B,EAAOJ,OAAS,EAClB,OAAOI,EAOT,IAJA,IAAIkG,EAAO,EACPC,EAAQ,EAGH1F,EAAI,EAAGA,EAAIT,EAAOJ,OAAS,EAAGa,IAAK,CAC1C,IAAInB,EAAIuG,EAAkB7F,EAAOS,GAAIT,EAAO,GAAIA,EAAOA,EAAOJ,OAAS,IACnEN,EAAI4G,IACNC,EAAQ1F,EACRyF,EAAO5G,EAEX,CAGA,GAAI4G,EAAON,EAAW,CACpB,IAAIQ,EAAapG,EAAOqG,MAAM,EAAGF,EAAQ,GACrCG,EAActG,EAAOqG,MAAMF,GAC3BI,EAAiBZ,EAAeS,EAAYR,GAC5CY,EAAkBb,EAAeW,EAAaV,GAClD,OAAOW,EAAeF,MAAM,EAAGE,EAAe3G,OAAS,GAAGoF,OAAOwB,EACnE,CACE,MAAO,CAACxG,EAAO,GAAIA,EAAOA,EAAOJ,OAAS,GAE9C,CAGyB+F,CADVnG,EAAWC,EAAM,GAAG,GAAO,GACM,GAC1CgH,EAAyBf,EAAiB9F,OAC5C8G,EAAqB,GAEhBjG,EAAI,EAAGA,EAAIgG,EAAwBhG,IAAK,CAC/C,IAAMkG,EAAyBjB,EAAiBjF,GAC1CmG,EAAsBlB,EAAiBjF,EAAI,IAAMkG,EAC7C,IAANlG,EACFiG,EAAmB/F,KAAK,CAAE/B,KAAM,IAAKhB,EAAG+I,EAAuB/I,EAAGC,EAAG8I,EAAuB9I,IAExF4C,IAAMgG,EAAyB,EACjCC,EAAmB/F,KAAK,CAAE/B,KAAM,IAAKhB,EAAG+I,EAAuB/I,EAAGC,EAAG8I,EAAuB9I,IAE5F6I,EAAmB/F,KAAK,CAAE/B,KAAM,IAAKK,GAAI0H,EAAuB/I,EAAGsB,GAAIyH,EAAuB9I,EAAGD,GAAI+I,EAAuB/I,EAAIgJ,EAAoBhJ,GAAK,EAAGC,GAAI8I,EAAuB9I,EAAI+I,EAAoB/I,GAAK,GAG1N,CAEA,OADA4B,EAAKH,EAAIoH,EACFjH,CACT,CAsHO,SAASoH,EAAqBC,GACnC,IAAM7G,EArHD,SAA+B6G,GAmEpC,SAASC,EAAeC,GACtB,IAG0BC,EAFtBhH,EAAc,GACdkG,EAAQ,EAAEe,EAAA5D,EAFC0D,EAAKhH,QAGM,IAA1B,IAAAkH,EAAA3D,MAAA0D,EAAAC,EAAA1D,KAAAC,MAA4B,KAAjBqC,EAAKmB,EAAAtD,MACR/F,EAAIkI,EAAMlI,EACVC,EAAIiI,EAAMjI,EACF,IAAVsI,EACFlG,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,EAAGC,EAAGA,IAEpCoC,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,EAAGC,EAAGA,IAEtCsI,GAAS,CACX,CAAC,OAAAlB,GAAAiC,EAAAhC,EAAAD,EAAA,SAAAiC,EAAA/B,GAAA,CAID,MAHkB,YAAd6B,EAAKpI,MACPqB,EAASU,KAAK,CAAE/B,KAAM,MAEjBqB,CACT,CAEA,IAAIA,EAAW,GACf,OAAQ6G,EAAQlI,MACd,IAAK,OACHqB,EAzFJ,SAAwBkH,GACtB,IAAMvJ,EAAIuJ,EAAKvJ,EACTC,EAAIsJ,EAAKtJ,EACTuJ,EAAQD,EAAKC,MACbC,EAASF,EAAKE,OAChBvI,EAAKqI,EAAKrI,IAAM,EAChBC,EAAKoI,EAAKpI,IAAM,EAEhBkB,EAAc,GAmBlB,OAlBW,IAAPnB,GAAmB,IAAPC,GACdkB,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,EAAGC,EAAGA,IACpCoC,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,EAAIwJ,IAClCnH,EAASU,KAAK,CAAE/B,KAAM,IAAKf,EAAGA,EAAIwJ,IAClCpH,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,IAC9BqC,EAASU,KAAK,CAAE/B,KAAM,QAEtBqB,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,EAAIkB,EAAIjB,EAAGA,IACzCoC,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,EAAIwJ,EAAQtI,IAC1CmB,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAIA,EAAIC,GAAIA,EAAIsC,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGA,EAAIwJ,EAAOvJ,EAAGA,EAAIkB,IACjHkB,EAASU,KAAK,CAAE/B,KAAM,IAAKf,EAAGA,EAAIwJ,EAAStI,IAC3CkB,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAIA,EAAIC,GAAIA,EAAIsC,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGA,EAAIwJ,EAAQtI,EAAIjB,EAAGA,EAAIwJ,IACtHpH,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGA,EAAIkB,IAClCmB,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAIA,EAAIC,GAAIA,EAAIsC,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGA,EAAGC,EAAGA,EAAIwJ,EAAStI,IAClHkB,EAASU,KAAK,CAAE/B,KAAM,IAAKf,EAAGA,EAAIkB,IAClCkB,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAIA,EAAIC,GAAIA,EAAIsC,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGA,EAAIkB,EAAIjB,EAAGA,IAC1GoC,EAASU,KAAK,CAAE/B,KAAM,OAEjBqB,CACT,CA6DeqH,CAAeR,GAC1B,MACF,IAAK,SACH7G,EA9DJ,SAA0BsH,GACxB,IAAMzJ,EAAKyJ,EAAOzJ,GACZC,EAAKwJ,EAAOxJ,GACZC,EAAIuJ,EAAOvJ,EACbiC,EAAc,GAKlB,OAJAA,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGE,EAAKE,EAAGH,EAAGE,IACzCkC,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAId,EAAGe,GAAIf,EAAGqD,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGE,EAAKE,EAAGH,EAAGE,IACxGkC,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAId,EAAGe,GAAIf,EAAGqD,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGE,EAAKE,EAAGH,EAAGE,IACxGkC,EAASU,KAAK,CAAE/B,KAAM,MACfqB,CACT,CAoDeuH,CAAiBV,GAC5B,MACF,IAAK,UACH7G,EArDJ,SAA2BwH,GACzB,IAAM3J,EAAK2J,EAAQ3J,GACbC,EAAK0J,EAAQ1J,GACbe,EAAK2I,EAAQ3I,GACbC,EAAK0I,EAAQ1I,GACfkB,EAAc,GAKlB,OAJAA,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGE,EAAKgB,EAAIjB,EAAGE,IAC1CkC,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAIA,EAAIC,GAAIA,EAAIsC,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGE,EAAKgB,EAAIjB,EAAGE,IAC3GkC,EAASU,KAAK,CAAE/B,KAAM,IAAKE,GAAIA,EAAIC,GAAIA,EAAIsC,cAAe,EAAGC,aAAc,EAAGC,UAAW,EAAG3D,EAAGE,EAAKgB,EAAIjB,EAAGE,IAC3GkC,EAASU,KAAK,CAAE/B,KAAM,MACfqB,CACT,CA0CeyH,CAAkBZ,GAC7B,MACF,IAAK,OACH7G,EA3CJ,SAAwB0H,GACtB,IAAM1I,EAAK0I,EAAK1I,GACVC,EAAKyI,EAAKzI,GACVC,EAAKwI,EAAKxI,GACVC,EAAKuI,EAAKvI,GACZa,EAAc,GAGlB,OAFAA,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGqB,EAAIpB,EAAGqB,IACrCe,EAASU,KAAK,CAAE/B,KAAM,IAAKhB,EAAGuB,EAAItB,EAAGuB,IAC9Ba,CACT,CAkCe2H,CAAed,GAC1B,MACF,IAAK,WAGL,IAAK,UACH7G,EAAW8G,EAAeD,GAC1B,MACF,IAAK,OACH7G,EAAW6G,EAAQxH,EACnB,MACF,QACE,MAAM,IAAIyF,MAAM,wBAADC,OAAyB8B,aAAO,EAAPA,EAASlI,OAErD,OAAOqB,CACT,CAGmB4H,CAAsBf,GACvC,OAAOzH,EAAUY,EAAU,GAAI6G,aAAO,EAAPA,EAAS7I,KAAM6I,aAAO,EAAPA,EAAS5I,OAAQ4I,aAAO,EAAPA,EAAS3I,YAAa2I,aAAO,EAAPA,EAAS1I,gBAAiB0I,aAAO,EAAPA,EAASzI,cAAeyI,aAAO,EAAPA,EAASxI,eAAgBwI,aAAO,EAAPA,EAASvI,UAAWuI,aAAO,EAAPA,EAAStI,QAASsI,aAAO,EAAPA,EAASrI,WACjN,CA4NO,SAASqJ,EAAsBC,EAAaC,GACjD,IAK2CC,EALrCC,EAAyB1I,EAAWuI,EAAO,GAAG,GAAM,GACpDI,EAAyB3I,EAAWwI,EAAO,GAAG,GAAM,GAEtDI,EAAW,CAAC,EACZC,EAAkB,GAAGC,EAAAhF,EACJ4E,GAAsB,IAA3C,IAAAI,EAAA/E,MAAA0E,EAAAK,EAAA9E,KAAAC,MAA6C,KAAlC8E,EAAMN,EAAAtE,MACT/F,EAAI2C,KAAKiI,MAAMD,EAAO3K,EAJb,GAKTC,EAAI0C,KAAKiI,MAAMD,EAAO1K,EALb,GAMVuK,EAASK,eAAe7K,KAC3BwK,EAASxK,GAAK,CAAC,GAEZwK,EAASxK,GAAG6K,eAAe5K,KAC9BuK,EAASxK,GAAGC,IAAK,EAErB,CAAC,OAAAoH,GAAAqD,EAAApD,EAAAD,EAAA,SAAAqD,EAAAnD,GAAA,KAC0CuD,EAD1CC,EAAArF,EACoB6E,GAAsB,IAA3C,IAAAQ,EAAApF,MAAAmF,EAAAC,EAAAnF,KAAAC,MAA6C,KAAlCmF,EAAMF,EAAA/E,MACT/F,EAAI2C,KAAKiI,MAAMI,EAAOhL,EAdb,GAeTC,EAAI0C,KAAKiI,MAAMI,EAAO/K,EAfb,GAgBVuK,EAASK,eAAe7K,KAC3BwK,EAASxK,GAAK,CAAC,GAEbwK,EAASxK,GAAG6K,eAAe5K,IAC7BwK,EAAgB1H,KAAK,CAAE/C,EApBV,EAoBaA,EAAcC,EApB3B,EAoB8BA,GAE/C,CAAC,OAAAoH,GAAA0D,EAAAzD,EAAAD,EAAA,SAAA0D,EAAAxD,GAAA,CACD,OAAOkD,CAET,C,8CC9pBO,SAASQ,EAAa7I,EAAgB/B,EAAYC,EAAgBC,EAA0BC,EAAkCC,EAA8BC,EAAgCC,EAAsBC,EAAkBC,GACzO,MAAO,CACLuB,OAAQA,GAAU,GAClB/B,KAAMA,GAAQ,OACdC,OAAQA,GAAU,OAClBC,YAAaA,GAAe,EAC5BC,gBAAiBA,GAAmB,GACpCC,cAAeA,GAAiB,OAChCC,eAAgBA,GAAkB,QAClCC,UAAWA,GAAa,GACxBC,QAASA,GAAW,EACpBC,WAAYA,GAAc,UAC1BC,IAAIC,EAAAA,EAAAA,KACJC,KAAM,UAEV,C,8CChBO,SAASkK,EAAc9I,EAAgB9B,EAAgBC,EAA0BC,EAAkCC,EAA8BC,EAAgCC,EAAsBC,EAAkBC,GAC9N,MAAO,CACLuB,OAAQA,GAAU,GAClB9B,OAAQA,GAAU,OAClBC,YAAaA,GAAe,EAC5BC,gBAAiBA,GAAmB,GACpCC,cAAeA,GAAiB,OAChCC,eAAgBA,GAAkB,QAClCC,UAAWA,GAAa,GACxBC,QAASA,GAAW,EACpBC,WAAYA,GAAc,UAC1BC,IAAIC,EAAAA,EAAAA,KACJC,KAAM,WAEV,C","sources":["webpack://vector/./src/graphic/elements/circle.ts","webpack://vector/./src/graphic/elements/ellipse.ts","webpack://vector/./src/graphic/elements/line.ts","webpack://vector/./src/graphic/elements/path.ts","webpack://vector/./src/graphic/elements/polygon.ts","webpack://vector/./src/graphic/elements/polyline.ts"],"sourcesContent":["import { x, y, cx, cy, r, fill, stroke, strokeWidth, strokeDasharray, strokeLinecap, strokeLinejoin, opacity, visibility, transform, id, elementType } from '../attributes/index';\nimport { uuidv4 } from '../../utilities/index';\n\nexport interface circle {\n  x: x;\n  y: y;\n  cx: cx;\n  cy: cy;\n  r: r;\n\n  fill?: fill;\n  stroke?: stroke;\n  strokeWidth?: strokeWidth;\n  strokeDasharray?: strokeDasharray;\n  strokeLinecap?: strokeLinecap;\n  strokeLinejoin?: strokeLinejoin;\n\n  transform?: transform;\n  opacity?: opacity;\n  visibility?: visibility;\n  id: id;\n  type: elementType;\n}\n\nexport function buildCircle(x: x, y: y, cx: cx, cy: cy, r: r, fill: fill, stroke: stroke, strokeWidth: strokeWidth, strokeDasharray: strokeDasharray, strokeLinecap: strokeLinecap, strokeLinejoin: strokeLinejoin, transform: transform, opacity: opacity, visibility: visibility): circle {\n  return {\n    x: x || 0,\n    y: y || 0,\n    cx: cx || 0,\n    cy: cy || 0,\n    r: r || 0,\n    fill: fill || 'none',\n    stroke: stroke || 'none',\n    strokeWidth: strokeWidth || 0,\n    strokeDasharray: strokeDasharray || '',\n    strokeLinecap: strokeLinecap || 'butt',\n    strokeLinejoin: strokeLinejoin || 'miter',\n    transform: transform || [],\n    opacity: opacity || 1,\n    visibility: visibility || 'visible',\n    id: uuidv4(),\n    type: 'circle'\n  };\n}\n","import { cx, cy, rx, ry, fill, stroke, strokeWidth, strokeDasharray, strokeLinecap, strokeLinejoin, opacity, visibility, transform, id, elementType, x, y } from '../attributes/index';\nimport { uuidv4 } from '../../utilities/index';\n\nexport interface ellipse {\n  x: x;\n  y: y;\n  cx: cx;\n  cy: cy;\n  rx: rx;\n  ry: ry;\n\n  fill?: fill;\n  stroke?: stroke;\n  strokeWidth?: strokeWidth;\n  strokeDasharray?: strokeDasharray;\n  strokeLinecap?: strokeLinecap;\n  strokeLinejoin?: strokeLinejoin;\n\n  transform?: transform;\n  opacity?: opacity;\n  visibility?: visibility;\n  id: id;\n  type: elementType;\n}\n\nexport function buildEllipse(x: x, y: y, cx: cx, cy: cy, rx: rx, ry: ry, fill: fill, stroke: stroke, strokeWidth: strokeWidth, strokeDasharray: strokeDasharray, strokeLinecap: strokeLinecap, strokeLinejoin: strokeLinejoin, transform: transform, opacity: opacity, visibility: visibility): ellipse {\n  return {\n    x: x || 0,\n    y: y || 0,\n    cx: cx || 0,\n    cy: cy || 0,\n    rx: rx || 0,\n    ry: ry || 0,\n    fill: fill || 'none',\n    stroke: stroke || 'none',\n    strokeWidth: strokeWidth || 0,\n    strokeDasharray: strokeDasharray || '',\n    strokeLinecap: strokeLinecap || 'butt',\n    strokeLinejoin: strokeLinejoin || 'miter',\n    transform: transform || [],\n    opacity: opacity || 1,\n    visibility: visibility || 'visible',\n    id: uuidv4(),\n    type: 'ellipse'\n  };\n}\n","import { x, y, stroke, strokeWidth, strokeDasharray, strokeLinecap, strokeLinejoin, opacity, visibility, transform, id, elementType } from '../attributes/index';\nimport { uuidv4 } from '../../utilities/index';\n\nexport interface line {\n  x1: x;\n  y1: y;\n  x2: x;\n  y2: y;\n\n  stroke?: stroke;\n  strokeWidth?: strokeWidth;\n  strokeDasharray?: strokeDasharray;\n  strokeLinecap?: strokeLinecap;\n  strokeLinejoin?: strokeLinejoin;\n\n  transform?: transform; // Transformations applied to the line\n  opacity?: opacity;\n  visibility?: visibility;\n  id: id;\n  type: elementType;\n}\n\nexport function buildLine(x1: x, y1: y, x2: x, y2: y, stroke: stroke, strokeWidth: strokeWidth, strokeDasharray: strokeDasharray, strokeLinecap: strokeLinecap, strokeLinejoin: strokeLinejoin, transform: transform, opacity: opacity, visibility: visibility): line {\n  return {\n    x1: x1 || 0,\n    y1: y1 || 0,\n    x2: x2 || 0,\n    y2: y2 || 0,\n    stroke: stroke || 'none',\n    strokeWidth: strokeWidth || 0,\n    strokeDasharray: strokeDasharray || '',\n    strokeLinecap: strokeLinecap || 'butt',\n    strokeLinejoin: strokeLinejoin || 'miter',\n    transform: transform || [],\n    opacity: opacity || 1,\n    visibility: visibility || 'visible',\n    id: uuidv4(),\n    type: 'line'\n  };\n}\n","import { d, fill, stroke, strokeWidth, strokeDasharray, strokeLinecap, strokeLinejoin, opacity, visibility, transform, id, elementType, point, points, boundingBox, metaPoints } from '../attributes/index';\nimport { uuidv4 } from '../../utilities/index';\nimport { rect } from './rect';\nimport { circle } from './circle';\nimport { ellipse } from './ellipse';\nimport { line } from './line';\nimport { polyline } from './polyline';\nimport { polygon } from './polygon';\nimport { element } from './index';\nimport { transformPoints } from '../transformation/index';\n\nexport interface path {\n  d: d;\n\n  metaPoints: metaPoints;\n\n  fill?: fill;\n  stroke?: stroke;\n  strokeWidth?: strokeWidth;\n  strokeDasharray?: strokeDasharray;\n  strokeLinecap?: strokeLinecap;\n  strokeLinejoin?: strokeLinejoin;\n\n  transform?: transform; // Transformations applied to the path\n  opacity?: opacity;\n  visibility?: visibility;\n  id: id;\n  type: elementType;\n}\n\nexport function buildPath(d: d, metaPoints: metaPoints, fill: fill, stroke: stroke, strokeWidth: strokeWidth, strokeDasharray: strokeDasharray, strokeLinecap: strokeLinecap, strokeLinejoin: strokeLinejoin, transform: transform, opacity: opacity, visibility: visibility): path {\n  return {\n    d: d || [],\n    metaPoints: metaPoints || [],\n    fill: fill || 'none',\n    stroke: stroke || 'none',\n    strokeWidth: strokeWidth || 0,\n    strokeDasharray: strokeDasharray || '',\n    strokeLinecap: strokeLinecap || 'butt',\n    strokeLinejoin: strokeLinejoin || 'miter',\n    transform: transform || [],\n    opacity: opacity || 1,\n    visibility: visibility || 'visible',\n    id: uuidv4(),\n    type: 'path'\n  };\n}\n\nexport function samplePathCommands(commands: d, precision: number = 1, detailedCurve: boolean = false): points {\n  function interpolateLinear(p0: point, p1: point, precision: number): points {\n    let segmentPoints: points = [];\n    const distance = Math.hypot(p1.x - p0.x, p1.y - p0.y);\n    const step = distance / precision;\n    for (let i = 0; i <= step; i++) {\n      const t = i / step;\n      const x = p0.x + (p1.x - p0.x) * t;\n      const y = p0.y + (p1.y - p0.y) * t;\n      segmentPoints.push({ x, y });\n    }\n    return segmentPoints;\n  }\n\n  function interpolateCubicBezier(p0: point, c1: point, c2: point, p1: point, precision: number, detailedCurve: boolean): points {\n    let segmentPoints: points = [];\n    const distance = Math.hypot(p1.x - p0.x, p1.y - p0.y);\n    let step = Math.round(distance / precision);\n    if (detailedCurve) {\n      step *= 1.5;\n    }\n    for (let i = 0; i <= step; i++) {\n      const t = i / step;\n      const x = Math.pow(1 - t, 3) * p0.x + 3 * Math.pow(1 - t, 2) * t * c1.x + 3 * (1 - t) * Math.pow(t, 2) * c2.x + Math.pow(t, 3) * p1.x;\n      const y = Math.pow(1 - t, 3) * p0.y + 3 * Math.pow(1 - t, 2) * t * c1.y + 3 * (1 - t) * Math.pow(t, 2) * c2.y + Math.pow(t, 3) * p1.y;\n      segmentPoints.push({ x, y });\n    }\n    return segmentPoints;\n  }\n\n  function interpolateQuadraticBezier(p0: point, c: point, p1: point, precision: number, detailedCurve: boolean): points {\n    let segmentPoints: points = [];\n    const distance = Math.hypot(p1.x - p0.x, p1.y - p0.y);\n    let step = Math.round(distance / precision);\n    if (detailedCurve) {\n      step *= 1.5;\n    }\n    for (let i = 0; i <= step; i++) {\n      const t = i / step;\n      const x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * c.x;\n      const y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * c.y;\n      segmentPoints.push({ x, y });\n    }\n    return segmentPoints;\n  }\n\n  function interpolateArc(p0: point, rx: number, ry: number, xAxisRotation: number, largeArcFlag: 0 | 1, sweepFlag: 0 | 1, x: number, y: number, precision: number, detailedCurve: boolean): points {\n    const distance = Math.hypot(x - p0.x, y - p0.y);\n    let step = Math.round(distance / precision);\n    if (detailedCurve) {\n      step *= 1.5;\n    }\n\n    // Helper to convert degrees to radians\n    const degToRad = (deg: number) => (deg * Math.PI) / 180;\n\n    // Calculate rotation matrix\n    const rotationRad = degToRad(xAxisRotation);\n    const cosRot = Math.cos(rotationRad);\n    const sinRot = Math.sin(rotationRad);\n\n    // Compute center of the ellipse and the angles\n    const dx = (p0.x - x) / 2;\n    const dy = (p0.y - y) / 2;\n\n    // Transform to the ellipse's coordinate space\n    const x1p = cosRot * dx + sinRot * dy;\n    const y1p = -sinRot * dx + cosRot * dy;\n\n    // Correct radii if necessary\n    const rxSq = rx ** 2;\n    const rySq = ry ** 2;\n    const x1pSq = x1p ** 2;\n    const y1pSq = y1p ** 2;\n\n    let radicant = (rxSq * rySq - rxSq * y1pSq - rySq * x1pSq) / (rxSq * y1pSq + rySq * x1pSq);\n    radicant = Math.max(0, radicant); // Ensure non-negative\n    const coef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(radicant);\n\n    const cxp = coef * ((rx * y1p) / ry);\n    const cyp = coef * (-(ry * x1p) / rx);\n\n    // Transform back to the original coordinate space\n    const cx = cosRot * cxp - sinRot * cyp + (p0.x + x) / 2;\n    const cy = sinRot * cxp + cosRot * cyp + (p0.y + y) / 2;\n\n    // Start and end angles\n    const theta1 = Math.atan2((y1p - cyp) / ry, (x1p - cxp) / rx);\n    const deltaTheta = Math.atan2((-y1p - cyp) / ry, (-x1p - cxp) / rx) - theta1;\n\n    // Ensure the angle is swept in the correct direction\n    const adjustedDeltaTheta = sweepFlag === 0 && deltaTheta > 0 ? deltaTheta - 2 * Math.PI : deltaTheta;\n    const finalDeltaTheta = sweepFlag === 1 && deltaTheta < 0 ? deltaTheta + 2 * Math.PI : adjustedDeltaTheta;\n\n    // Sample the arc\n    const segmentPoints = [];\n    for (let i = 0; i <= step; i++) {\n      const t = i / step; // Proportion of the arc\n      const theta = theta1 + t * finalDeltaTheta;\n\n      // Parametric equation of the ellipse\n      const x = cosRot * (rx * Math.cos(theta)) - sinRot * (ry * Math.sin(theta)) + cx;\n      const y = sinRot * (rx * Math.cos(theta)) + cosRot * (ry * Math.sin(theta)) + cy;\n\n      segmentPoints.push({ x, y });\n    }\n    return segmentPoints;\n  }\n\n  let points: points = [];\n  let currentPoint: point = { x: 0, y: 0 };\n  let previousControlPoint: point | null = null;\n\n  for (const command of commands) {\n    switch (command.type) {\n      case 'M':\n        currentPoint = { x: command.x, y: command.y };\n        points.push(currentPoint);\n        previousControlPoint = null;\n        break;\n      case 'L':\n        const lineEnd = { x: command.x, y: command.y };\n        points.push(...interpolateLinear(currentPoint, lineEnd, precision));\n        currentPoint = lineEnd;\n        previousControlPoint = null;\n        break;\n      case 'H':\n        const horizontalEnd = { x: command.x, y: currentPoint.y };\n        points.push(...interpolateLinear(currentPoint, horizontalEnd, precision));\n        currentPoint = horizontalEnd;\n        previousControlPoint = null;\n        break;\n      case 'V':\n        const verticalEnd = { x: currentPoint.x, y: command.y };\n        points.push(...interpolateLinear(currentPoint, verticalEnd, precision));\n        currentPoint = verticalEnd;\n        previousControlPoint = null;\n        break;\n      case 'C':\n        const cubicStart = currentPoint;\n        const cubicControl1 = { x: command.x1, y: command.y1 };\n        const cubicControl2 = { x: command.x2, y: command.y2 };\n        const cubicEnd = { x: command.x, y: command.y };\n        points.push(...interpolateCubicBezier(cubicStart, cubicControl1, cubicControl2, cubicEnd, precision, detailedCurve));\n        currentPoint = cubicEnd;\n        previousControlPoint = cubicControl2;\n        break;\n      case 'S':\n        const smoothStart = currentPoint;\n        const smoothControl1 = previousControlPoint ? { x: 2 * smoothStart.x - previousControlPoint.x, y: 2 * smoothStart.y - previousControlPoint.y } : smoothStart;\n        const smoothControl2 = { x: command.x2, y: command.y2 };\n        const smoothEnd = { x: command.x, y: command.y };\n        points.push(...interpolateCubicBezier(smoothStart, smoothControl1, smoothControl2, smoothEnd, precision, detailedCurve));\n        currentPoint = smoothEnd;\n        previousControlPoint = smoothControl2;\n        break;\n      case 'Q':\n        const quadStart = currentPoint;\n        const quadControl = { x: command.x, y: command.y };\n        const quadEnd = { x: command.x1, y: command.y1 };\n        points.push(...interpolateQuadraticBezier(quadStart, quadControl, quadEnd, precision, detailedCurve));\n        currentPoint = quadEnd;\n        previousControlPoint = quadControl;\n        break;\n      case 'T':\n        const smoothQuadStart = currentPoint;\n        const smoothQuadControl = previousControlPoint ? { x: 2 * smoothQuadStart.x - previousControlPoint.x, y: 2 * smoothQuadStart.y - previousControlPoint.y } : smoothQuadStart;\n        const smoothQuadEnd = { x: command.x, y: command.y };\n        points.push(...interpolateQuadraticBezier(smoothQuadStart, smoothQuadControl, smoothQuadEnd, precision, detailedCurve));\n        currentPoint = smoothQuadEnd;\n        previousControlPoint = smoothQuadControl;\n        break;\n      case 'A':\n        points.push(...interpolateArc(currentPoint, command.rx, command.ry, command.xAxisRotation, command.largeArcFlag, command.sweepFlag, command.x, command.y, precision, detailedCurve));\n        currentPoint = { x: command.x, y: command.y };\n        previousControlPoint = null;\n        break;\n      case 'Z':\n        if (points.length > 0) {\n          points.push(points[0]); // Close path by connecting to the start\n        }\n        previousControlPoint = null;\n        break;\n      default:\n        throw new Error(`Unsupported command type: ${command.type}`);\n    }\n  }\n  return points;\n}\n\nexport function samplePath(path: path, precision: number = 1, flatten: boolean = false, detailedCurve: boolean = false): points {\n  let points = samplePathCommands(path.d, precision, detailedCurve);\n  if (flatten) {\n    if (typeof path.transform === 'object' && Array.isArray(path.transform)) {\n      if (path.transform.length > 0) {\n        points = transformPoints(points, path.transform);\n      }\n    }\n  }\n  return points;\n}\n\nexport function smoothPath(path: path): path {\n  function simplifyPoints(points: points, tolerance: number): points {\n    function distanceToSegment(point: point, start: point, end: point): number {\n      let dx = end.x - start.x;\n      let dy = end.y - start.y;\n      let d = dx * dx + dy * dy;\n      let t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;\n\n      if (t < 0) {\n        dx = point.x - start.x;\n        dy = point.y - start.y;\n      } else if (t > 1) {\n        dx = point.x - end.x;\n        dy = point.y - end.y;\n      } else {\n        var closestPoint = { x: start.x + t * dx, y: start.y + t * dy };\n        dx = point.x - closestPoint.x;\n        dy = point.y - closestPoint.y;\n      }\n\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    if (points.length < 3) {\n      return points;\n    }\n\n    let dmax = 0;\n    let index = 0;\n\n    // Find the point with the maximum distance\n    for (let i = 1; i < points.length - 1; i++) {\n      let d = distanceToSegment(points[i], points[0], points[points.length - 1]);\n      if (d > dmax) {\n        index = i;\n        dmax = d;\n      }\n    }\n\n    // If max distance is greater than tolerance, split the curve\n    if (dmax > tolerance) {\n      let leftPoints = points.slice(0, index + 1);\n      let rightPoints = points.slice(index);\n      let simplifiedLeft = simplifyPoints(leftPoints, tolerance);\n      let simplifiedRight = simplifyPoints(rightPoints, tolerance);\n      return simplifiedLeft.slice(0, simplifiedLeft.length - 1).concat(simplifiedRight);\n    } else {\n      return [points[0], points[points.length - 1]];\n    }\n  }\n\n  const points = samplePath(path, 1, false, false);\n  const simplifiedPoints = simplifyPoints(points, 1);\n  const simplifiedPointsLength = simplifiedPoints.length;\n  let simplifiedCommands = [];\n\n  for (let i = 0; i < simplifiedPointsLength; i++) {\n    const currentSimplifiedPoint = simplifiedPoints[i];\n    const nextSimplifiedPoint = simplifiedPoints[i + 1] || currentSimplifiedPoint;\n    if (i === 0) {\n      simplifiedCommands.push({ type: 'M', x: currentSimplifiedPoint.x, y: currentSimplifiedPoint.y });\n    } else {\n      if (i === simplifiedPointsLength - 1) {\n        simplifiedCommands.push({ type: 'L', x: currentSimplifiedPoint.x, y: currentSimplifiedPoint.y });\n      } else {\n        simplifiedCommands.push({ type: 'Q', x1: currentSimplifiedPoint.x, y1: currentSimplifiedPoint.y, x: (currentSimplifiedPoint.x + nextSimplifiedPoint.x) / 2, y: (currentSimplifiedPoint.y + nextSimplifiedPoint.y) / 2 });\n      }\n    }\n  }\n  path.d = simplifiedCommands;\n  return path;\n}\n\nexport function elementToPathCommands(element: element): d {\n  function rectToCommands(rect: rect): d {\n    const x = rect.x;\n    const y = rect.y;\n    const width = rect.width;\n    const height = rect.height;\n    let rx = rect.rx || 0;\n    let ry = rect.ry || 0;\n\n    let commands: d = [];\n    if (rx === 0 && ry === 0) {\n      commands.push({ type: 'M', x: x, y: y });\n      commands.push({ type: 'H', x: x + width });\n      commands.push({ type: 'V', y: y + height });\n      commands.push({ type: 'H', x: x });\n      commands.push({ type: 'Z' });\n    } else {\n      commands.push({ type: 'M', x: x + rx, y: y });\n      commands.push({ type: 'H', x: x + width - rx });\n      commands.push({ type: 'A', rx: rx, ry: ry, xAxisRotation: 0, largeArcFlag: 0, sweepFlag: 1, x: x + width, y: y + ry });\n      commands.push({ type: 'V', y: y + height - ry });\n      commands.push({ type: 'A', rx: rx, ry: ry, xAxisRotation: 0, largeArcFlag: 0, sweepFlag: 1, x: x + width - rx, y: y + height });\n      commands.push({ type: 'H', x: x + rx });\n      commands.push({ type: 'A', rx: rx, ry: ry, xAxisRotation: 0, largeArcFlag: 0, sweepFlag: 1, x: x, y: y + height - ry });\n      commands.push({ type: 'V', y: y + ry });\n      commands.push({ type: 'A', rx: rx, ry: ry, xAxisRotation: 0, largeArcFlag: 0, sweepFlag: 1, x: x + rx, y: y });\n      commands.push({ type: 'Z' });\n    }\n    return commands;\n  }\n\n  function circleToCommands(circle: circle): d {\n    const cx = circle.cx;\n    const cy = circle.cy;\n    const r = circle.r;\n    let commands: d = [];\n    commands.push({ type: 'M', x: cx - r, y: cy });\n    commands.push({ type: 'A', rx: r, ry: r, xAxisRotation: 0, largeArcFlag: 1, sweepFlag: 0, x: cx + r, y: cy });\n    commands.push({ type: 'A', rx: r, ry: r, xAxisRotation: 0, largeArcFlag: 1, sweepFlag: 0, x: cx - r, y: cy });\n    commands.push({ type: 'Z' });\n    return commands;\n  }\n\n  function ellipseToCommands(ellipse: ellipse): d {\n    const cx = ellipse.cx;\n    const cy = ellipse.cy;\n    const rx = ellipse.rx;\n    const ry = ellipse.ry;\n    let commands: d = [];\n    commands.push({ type: 'M', x: cx - rx, y: cy });\n    commands.push({ type: 'A', rx: rx, ry: ry, xAxisRotation: 0, largeArcFlag: 1, sweepFlag: 0, x: cx + rx, y: cy });\n    commands.push({ type: 'A', rx: rx, ry: ry, xAxisRotation: 0, largeArcFlag: 1, sweepFlag: 0, x: cx - rx, y: cy });\n    commands.push({ type: 'Z' });\n    return commands;\n  }\n\n  function lineToCommands(line: line): d {\n    const x1 = line.x1;\n    const y1 = line.y1;\n    const x2 = line.x2;\n    const y2 = line.y2;\n    let commands: d = [];\n    commands.push({ type: 'M', x: x1, y: y1 });\n    commands.push({ type: 'L', x: x2, y: y2 });\n    return commands;\n  }\n\n  function polyToCommands(poly: polyline | polygon): d {\n    const points = poly.points;\n    let commands: d = [];\n    let index = 0;\n    for (const point of points) {\n      const x = point.x;\n      const y = point.y;\n      if (index === 0) {\n        commands.push({ type: 'M', x: x, y: y });\n      } else {\n        commands.push({ type: 'L', x: x, y: y });\n      }\n      index += 1;\n    }\n    if (poly.type === 'polygon') {\n      commands.push({ type: 'Z' });\n    }\n    return commands;\n  }\n\n  let commands = [];\n  switch (element.type) {\n    case 'rect':\n      commands = rectToCommands(element);\n      break;\n    case 'circle':\n      commands = circleToCommands(element);\n      break;\n    case 'ellipse':\n      commands = ellipseToCommands(element);\n      break;\n    case 'line':\n      commands = lineToCommands(element);\n      break;\n    case 'polyline':\n      commands = polyToCommands(element);\n      break;\n    case 'polygon':\n      commands = polyToCommands(element);\n      break;\n    case 'path':\n      commands = element.d;\n      break;\n    default:\n      throw new Error(`Unsupported element: ${element?.type}`);\n  }\n  return commands;\n}\n\nexport function buildPathFromElement(element: element): path {\n  const commands = elementToPathCommands(element);\n  return buildPath(commands, [], element?.fill, element?.stroke, element?.strokeWidth, element?.strokeDasharray, element?.strokeLinecap, element?.strokeLinejoin, element?.transform, element?.opacity, element?.visibility);\n}\n\nexport function getPathBoundingBox(path: path): boundingBox {\n  const points = samplePath(path, 1, true, true);\n  let pX = [];\n  let pY = [];\n  for (const point of points) {\n    pX.push(point.x);\n    pY.push(point.y);\n  }\n  const x0 = Math.min(...pX);\n  const y0 = Math.min(...pY);\n  const x1 = Math.max(...pX);\n  const y1 = Math.max(...pY);\n  return { x0, y0, x1, y1 };\n}\n\nexport function getPathCommandsLength(commands: d): number {\n  function getStep(linearDistance: number): number {\n    const step = Math.floor((10 * Math.log10(linearDistance)) / Math.log10(30));\n    return step;\n  }\n\n  function measureLinear(p0: point, p1: point): number {\n    const length = Math.hypot(p1.x - p0.x, p1.y - p0.y);\n    return length;\n  }\n\n  function measureCubicBezier(p0: point, c1: point, c2: point, p1: point): number {\n    function derivative(t: number, p0: point, c1: point, c2: point, p1: point): [number, number] {\n      // dx/dt and dy/dt\n      const dx = 3 * (1 - t) ** 2 * (c1.x - p0.x) + 6 * (1 - t) * t * (c2.x - c1.x) + 3 * t ** 2 * (p1.x - c2.x);\n      const dy = 3 * (1 - t) ** 2 * (c1.y - p0.y) + 6 * (1 - t) * t * (c2.y - c1.y) + 3 * t ** 2 * (p1.y - c2.y);\n      return [dx, dy];\n    }\n    const linearDistance = Math.hypot(p1.x - p0.x, p1.y - p0.y);\n    let step = getStep(linearDistance);\n\n    // Numerical integration using the trapezoidal rule\n    let length = 0;\n    for (let i = 1; i <= step; i++) {\n      const t1 = (i - 1) / step;\n      const t2 = i / step;\n\n      // Derivatives at t1 and t2\n      const d1 = derivative(t1, p0, c1, c2, p1);\n      const d2 = derivative(t2, p0, c1, c2, p1);\n\n      // Approximate length for this step\n      const segmentLength = Math.sqrt(Math.pow((d1[0] + d2[0]) / 2, 2) + Math.pow((d1[1] + d2[1]) / 2, 2)) * (1 / step); // Multiply by step size\n      length += segmentLength;\n    }\n    return length;\n  }\n\n  function measureQuadraticBezier(p0: point, c: point, p1: point): number {\n    function derivative(t: number, p0: point, c: point, p1: point): [number, number] {\n      const dx = 2 * (1 - t) * (p1.x - p0.x) + 2 * t * (c.x - p1.x);\n      const dy = 2 * (1 - t) * (p1.y - p0.y) + 2 * t * (c.y - p1.y);\n      return [dx, dy];\n    }\n\n    const linearDistance = Math.hypot(p0.x - c.x, p0.y - c.y) + Math.hypot(c.x - p1.x, c.y - p1.y);\n    let step = getStep(linearDistance);\n    let length = 0;\n    for (let i = 1; i <= step; i++) {\n      const t1 = (i - 1) / step;\n      const t2 = i / step;\n\n      // Derivatives at t1 and t2\n      const d1 = derivative(t1, p0, c, p1);\n      const d2 = derivative(t2, p0, c, p1);\n\n      // Approximate length for this step\n      const segmentLength = Math.sqrt(Math.pow((d1[0] + d2[0]) / 2, 2) + Math.pow((d1[1] + d2[1]) / 2, 2)) * (1 / step); // Multiply by step size\n      console.log(t1, t2, d1, d2, segmentLength);\n      length += segmentLength;\n    }\n    return length;\n  }\n\n  function measureArc(p0: point, rx: number, ry: number, xAxisRotation: number, largeArcFlag: 0 | 1, sweepFlag: 0 | 1, x: number, y: number): number {\n    const linearDistance = Math.hypot(x - p0.x, y - p0.y);\n    let step = getStep(linearDistance);\n\n    // Helper to convert degrees to radians\n    const degToRad = (deg: number) => (deg * Math.PI) / 180;\n\n    // Calculate rotation matrix\n    const rotationRad = degToRad(xAxisRotation);\n    const cosRot = Math.cos(rotationRad);\n    const sinRot = Math.sin(rotationRad);\n\n    // Compute center of the ellipse and the angles\n    const dx = (p0.x - x) / 2;\n    const dy = (p0.y - y) / 2;\n\n    // Transform to the ellipse's coordinate space\n    const x1p = cosRot * dx + sinRot * dy;\n    const y1p = -sinRot * dx + cosRot * dy;\n\n    // Correct radii if necessary\n    const rxSq = rx ** 2;\n    const rySq = ry ** 2;\n    const x1pSq = x1p ** 2;\n    const y1pSq = y1p ** 2;\n\n    let radicant = (rxSq * rySq - rxSq * y1pSq - rySq * x1pSq) / (rxSq * y1pSq + rySq * x1pSq);\n    radicant = Math.max(0, radicant); // Ensure non-negative\n    const coef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(radicant);\n\n    const cxp = coef * ((rx * y1p) / ry);\n    const cyp = coef * (-(ry * x1p) / rx);\n\n    // Transform back to the original coordinate space\n    const cx = cosRot * cxp - sinRot * cyp + (p0.x + x) / 2;\n    const cy = sinRot * cxp + cosRot * cyp + (p0.y + y) / 2;\n\n    // Start and end angles\n    const theta1 = Math.atan2((y1p - cyp) / ry, (x1p - cxp) / rx);\n    const deltaTheta = Math.atan2((-y1p - cyp) / ry, (-x1p - cxp) / rx) - theta1;\n\n    // Ensure the angle is swept in the correct direction\n    const adjustedDeltaTheta = sweepFlag === 0 && deltaTheta > 0 ? deltaTheta - 2 * Math.PI : deltaTheta;\n    const finalDeltaTheta = sweepFlag === 1 && deltaTheta < 0 ? deltaTheta + 2 * Math.PI : adjustedDeltaTheta;\n\n    let length = 0;\n    for (let i = 1; i < step; i++) {\n      const t0 = (i - 1) / step; // Proportion of the arc\n      const theta0 = theta1 + t0 * finalDeltaTheta;\n      const x0 = cosRot * (rx * Math.cos(theta0)) - sinRot * (ry * Math.sin(theta0)) + cx;\n      const y0 = sinRot * (rx * Math.cos(theta0)) + cosRot * (ry * Math.sin(theta0)) + cy;\n      const t = i / step; // Proportion of the arc\n      const theta = theta1 + t * finalDeltaTheta;\n      const x = cosRot * (rx * Math.cos(theta)) - sinRot * (ry * Math.sin(theta)) + cx;\n      const y = sinRot * (rx * Math.cos(theta)) + cosRot * (ry * Math.sin(theta)) + cy;\n      length += Math.hypot(x0 - x, y0 - y);\n    }\n    return length;\n  }\n\n  let length: number = 0;\n  let currentPoint: point = { x: 0, y: 0 };\n  let previousControlPoint: point | null = null;\n\n  for (const command of commands) {\n    switch (command.type) {\n      case 'M':\n        currentPoint = { x: command.x, y: command.y };\n        length += 0;\n        previousControlPoint = null;\n        break;\n      case 'L':\n        const lineEnd = { x: command.x, y: command.y };\n        length += measureLinear(currentPoint, lineEnd);\n        currentPoint = lineEnd;\n        previousControlPoint = null;\n        break;\n      case 'H':\n        const horizontalEnd = { x: command.x, y: currentPoint.y };\n        length += measureLinear(currentPoint, horizontalEnd);\n        currentPoint = horizontalEnd;\n        previousControlPoint = null;\n        break;\n      case 'V':\n        const verticalEnd = { x: currentPoint.x, y: command.y };\n        length += measureLinear(currentPoint, verticalEnd);\n        currentPoint = verticalEnd;\n        previousControlPoint = null;\n        break;\n      case 'C':\n        const cubicStart = currentPoint;\n        const cubicControl1 = { x: command.x1, y: command.y1 };\n        const cubicControl2 = { x: command.x2, y: command.y2 };\n        const cubicEnd = { x: command.x, y: command.y };\n        length += measureCubicBezier(cubicStart, cubicControl1, cubicControl2, cubicEnd);\n        currentPoint = cubicEnd;\n        previousControlPoint = cubicControl2;\n        break;\n      case 'S':\n        const smoothStart = currentPoint;\n        const smoothControl1 = previousControlPoint ? { x: 2 * smoothStart.x - previousControlPoint.x, y: 2 * smoothStart.y - previousControlPoint.y } : smoothStart;\n        const smoothControl2 = { x: command.x2, y: command.y2 };\n        const smoothEnd = { x: command.x, y: command.y };\n        length += measureCubicBezier(smoothStart, smoothControl1, smoothControl2, smoothEnd);\n        currentPoint = smoothEnd;\n        previousControlPoint = smoothControl2;\n        break;\n      case 'Q':\n        const quadStart = currentPoint;\n        const quadControl = { x: command.x, y: command.y };\n        const quadEnd = { x: command.x1, y: command.y1 };\n        length += measureQuadraticBezier(quadStart, quadControl, quadEnd);\n        currentPoint = quadEnd;\n        previousControlPoint = quadControl;\n        break;\n      case 'T':\n        const smoothQuadStart = currentPoint;\n        const smoothQuadControl = previousControlPoint ? { x: 2 * smoothQuadStart.x - previousControlPoint.x, y: 2 * smoothQuadStart.y - previousControlPoint.y } : smoothQuadStart;\n        const smoothQuadEnd = { x: command.x, y: command.y };\n        length += measureQuadraticBezier(smoothQuadStart, smoothQuadControl, smoothQuadEnd);\n        currentPoint = smoothQuadEnd;\n        previousControlPoint = smoothQuadControl;\n        break;\n      case 'A':\n        length += measureArc(currentPoint, command.rx, command.ry, command.xAxisRotation, command.largeArcFlag, command.sweepFlag, command.x, command.y);\n        currentPoint = { x: command.x, y: command.y };\n        previousControlPoint = null;\n        break;\n      case 'Z':\n        length += 0;\n        previousControlPoint = null;\n        break;\n      default:\n        throw new Error(`Unsupported command type: ${command.type}`);\n    }\n  }\n  return length;\n}\n\nexport function findPathIntersections(path1: path, path2: path): points {\n  const approxmiatePath1Points = samplePath(path1, 2, true, true);\n  const approxmiatePath2Points = samplePath(path2, 2, true, true);\n  const interval = 4;\n  let pointMap = {};\n  let candidatePoints = [];\n  for (const point1 of approxmiatePath1Points) {\n    const x = Math.floor(point1.x / interval);\n    const y = Math.floor(point1.y / interval);\n    if (!pointMap.hasOwnProperty(x)) {\n      pointMap[x] = {};\n    }\n    if (!pointMap[x].hasOwnProperty(y)) {\n      pointMap[x][y] = true;\n    }\n  }\n  for (const point2 of approxmiatePath2Points) {\n    const x = Math.floor(point2.x / interval);\n    const y = Math.floor(point2.y / interval);\n    if (!pointMap.hasOwnProperty(x)) {\n      pointMap[x] = {};\n    }\n    if (pointMap[x].hasOwnProperty(y)) {\n      candidatePoints.push({ x: x * interval, y: y * interval });\n    }\n  }\n  return candidatePoints;\n  // TODO: check overlaps, further check\n}\n","import { points, fill, stroke, strokeWidth, strokeDasharray, strokeLinecap, strokeLinejoin, opacity, visibility, transform, id, elementType } from '../attributes/index';\nimport { uuidv4 } from '../../utilities/index';\n\nexport interface polygon {\n  points: points;\n\n  fill?: fill;\n  stroke?: stroke;\n  strokeWidth?: strokeWidth;\n  strokeDasharray?: strokeDasharray;\n  strokeLinecap?: strokeLinecap;\n  strokeLinejoin?: strokeLinejoin;\n\n  transform?: transform; // Transformations applied to the polygon\n  opacity?: opacity;\n  visibility?: visibility;\n  id: id;\n  type: elementType;\n}\n\nexport function buildPolygon(points: points, fill: fill, stroke: stroke, strokeWidth: strokeWidth, strokeDasharray: strokeDasharray, strokeLinecap: strokeLinecap, strokeLinejoin: strokeLinejoin, transform: transform, opacity: opacity, visibility: visibility): polygon {\n  return {\n    points: points || [],\n    fill: fill || 'none',\n    stroke: stroke || 'none',\n    strokeWidth: strokeWidth || 0,\n    strokeDasharray: strokeDasharray || '',\n    strokeLinecap: strokeLinecap || 'butt',\n    strokeLinejoin: strokeLinejoin || 'miter',\n    transform: transform || [],\n    opacity: opacity || 1,\n    visibility: visibility || 'visible',\n    id: uuidv4(),\n    type: 'polygon'\n  };\n}\n","import { points, stroke, strokeWidth, strokeDasharray, strokeLinecap, strokeLinejoin, opacity, visibility, transform, id, elementType } from '../attributes/index';\nimport { uuidv4 } from '../../utilities/index';\n\nexport interface polyline {\n  points: points;\n\n  stroke?: stroke;\n  strokeWidth?: strokeWidth;\n  strokeDasharray?: strokeDasharray;\n  strokeLinecap?: strokeLinecap;\n  strokeLinejoin?: strokeLinejoin;\n\n  transform?: transform; // Transformations applied to the polyline\n  opacity?: opacity;\n  visibility?: visibility;\n  id: id;\n  type: elementType;\n}\n\nexport function buildPolyline(points: points, stroke: stroke, strokeWidth: strokeWidth, strokeDasharray: strokeDasharray, strokeLinecap: strokeLinecap, strokeLinejoin: strokeLinejoin, transform: transform, opacity: opacity, visibility: visibility): polyline {\n  return {\n    points: points || [],\n    stroke: stroke || 'none',\n    strokeWidth: strokeWidth || 0,\n    strokeDasharray: strokeDasharray || '',\n    strokeLinecap: strokeLinecap || 'butt',\n    strokeLinejoin: strokeLinejoin || 'miter',\n    transform: transform || [],\n    opacity: opacity || 1,\n    visibility: visibility || 'visible',\n    id: uuidv4(),\n    type: 'polyline'\n  };\n}\n"],"names":["buildCircle","x","y","cx","cy","r","fill","stroke","strokeWidth","strokeDasharray","strokeLinecap","strokeLinejoin","transform","opacity","visibility","id","uuidv4","type","buildEllipse","rx","ry","buildLine","x1","y1","x2","y2","buildPath","d","metaPoints","samplePath","path","precision","arguments","length","undefined","flatten","detailedCurve","points","commands","interpolateLinear","p0","p1","segmentPoints","step","Math","hypot","i","t","push","interpolateCubicBezier","c1","c2","distance","round","pow","interpolateQuadraticBezier","c","interpolateArc","xAxisRotation","largeArcFlag","sweepFlag","rotationRad","PI","cosRot","cos","sinRot","sin","dx","dy","x1p","y1p","rxSq","rySq","x1pSq","y1pSq","radicant","max","coef","sqrt","cxp","cyp","theta1","atan2","deltaTheta","adjustedDeltaTheta","finalDeltaTheta","theta","_step","currentPoint","previousControlPoint","_iterator","_createForOfIteratorHelper","s","n","done","command","value","lineEnd","apply","_toConsumableArray","horizontalEnd","verticalEnd","cubicStart","cubicControl1","cubicControl2","cubicEnd","smoothStart","smoothControl1","smoothControl2","smoothEnd","quadStart","quadControl","quadEnd","smoothQuadStart","smoothQuadControl","smoothQuadEnd","Error","concat","err","e","f","samplePathCommands","_typeof","Array","isArray","transformPoints","smoothPath","simplifiedPoints","simplifyPoints","tolerance","distanceToSegment","point","start","end","closestPoint","dmax","index","leftPoints","slice","rightPoints","simplifiedLeft","simplifiedRight","simplifiedPointsLength","simplifiedCommands","currentSimplifiedPoint","nextSimplifiedPoint","buildPathFromElement","element","polyToCommands","poly","_step2","_iterator2","rect","width","height","rectToCommands","circle","circleToCommands","ellipse","ellipseToCommands","line","lineToCommands","elementToPathCommands","findPathIntersections","path1","path2","_step5","approxmiatePath1Points","approxmiatePath2Points","pointMap","candidatePoints","_iterator5","point1","floor","hasOwnProperty","_step6","_iterator6","point2","buildPolygon","buildPolyline"],"sourceRoot":""}